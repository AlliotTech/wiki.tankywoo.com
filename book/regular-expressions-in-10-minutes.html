<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/colorful.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
        <title>正则表达式必知必会 - Wiki · Tanky Woo</title>
        <meta name="keywords" content="wiki, makrdown, linux, python, cpp, ops, simiki"/>
        <meta name="description" content="Tanky Woo's personal wiki, powered by vim and markdown. Focus on Python, C/C++, Linux, Ops-Dev, Gentoo, and so on."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        

    </head>

    <body>
        <div id="container" class="typo">
            
    <div id="header">
        <div id="post-nav">
            
            <a href="/">Wiki · Tanky Woo</a> » <a href="/#book">book</a> » 正则表达式必知必会
            
        </div>
    </div>
    <div class="clearfix"></div>
    <div id="content">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">第1章 入门</a></li>
<li><a href="#2">第2章 匹配单个字符</a></li>
<li><a href="#3">第3章 匹配一组字符</a></li>
<li><a href="#4">第4章 使用元字符</a></li>
<li><a href="#5">第5章 重复匹配</a></li>
</ul>
</div>
<h2 id="1">第1章 入门</h2>
<blockquote>
<p>正则表达式的两种基本用途:「搜索」和「替换」。</p>
<p>在使用正则表达式的时候, 你将发现几乎所有的问题都有不止一 种解决方案。它们有的比较简单, 有的比较快速, 有的兼容性更好,有的功能更全。这么说吧, 在编写正则表达式的时候, 只有「对」、「错」两种选择的情况是相当少见的 —— 同一个问题往往会有多种解决方案。</p>
</blockquote>
<h2 id="2">第2章 匹配单个字符</h2>
<p>最简单的是匹配纯文本。</p>
<p>全局搜索: 针对有多个匹配结果, 大多数正则表达式引擎的默认行为是只返回第1个匹配结果。不过很多实现都提供了能够把所有的匹配结果全部找出来的机制。常见的元字符是 <code>g</code> (表示global)</p>
<p>大小写问题: 正则表达式是区分字母大小写的, 大多数正则表达的式实现也支持不区分字母大小写的匹配操作。常见的远字符是 <code>i</code> (表示ignore)</p>
<p>匹配任意单个字符: <code>.</code> 。</p>
<p>转义特殊字符: <code>\</code> 。比如上面的 <code>.</code> , 如果要把这个当成普通字符匹配, 则需要写为 <code>\.</code> ; 同理, 因为 <code>\</code> 是做转义用的特殊字符, 要匹配其本身, 则需要写为 <code>\\</code> 。后续的一些元字符, 如果要匹配其自身, 都需要转义。</p>
<p>正则表达式经常被简称为模式, 它们其实是一些由字符构成的字符串。这些字符可以是 普通字符(纯文本) 或 元字符(有特殊含义的特殊字符)。</p>
<h2 id="3">第3章 匹配一组字符</h2>
<p>匹配多个字符中的某一个: <code>[]</code>。里面定义多个字符的集合, 表示匹配该集合中任意一个字符。</p>
<p>如:</p>
<div class="hlcode"><pre><span class="p">[</span><span class="n">rR</span><span class="p">]</span><span class="n">e</span><span class="p">[</span><span class="n">gG</span><span class="p">]</span><span class="n">ex</span>  <span class="err">#</span> <span class="err">匹配</span> <span class="n">regex</span><span class="p">,</span> <span class="n">Regex</span><span class="p">,</span> <span class="n">reGex</span><span class="p">,</span> <span class="n">ReGex</span>
</pre></div>


<p>在集合里面, 还可以定义区间, 比如表示某个数字, 虽然可以使用<code>[0123456789]</code>但是不够简洁清晰, 可以:</p>
<div class="hlcode"><pre><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span>
</pre></div>


<p>甚至可以表示多个区间, 如表示所有大小写字母和数字:</p>
<div class="hlcode"><pre><span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">Za</span><span class="o">-</span><span class="n">z0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span>
</pre></div>


<p>注意 连字符<code>-</code> 只有在集合里面才表示一个特殊的元字符, 在集合外面只是一个普通字符。</p>
<p>在集合里, 还可以对集合做 取非操作, 使用<code>^</code>, 如表示除数字以外其它字符:</p>
<div class="hlcode"><pre><span class="p">[</span><span class="o">^</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span>
</pre></div>


<p>注意 ^ 的效果将作用于给定字符集合里的所有字符或字符区间, 而不是仅限于紧跟在 ^ 字符后面的那一个字符或字符区间。</p>
<h2 id="4">第4章 使用元字符</h2>
<p>元字符大致可以分为两种: 一种是用来匹配文本的(比如 <code>.</code>), 另一种是正则表达式的语法所要求的(比如 <code>[</code> 和 <code>]</code>)。</p>
<p>匹配空白字符:</p>
<ul>
<li><code>\n</code> 换行符</li>
<li><code>\r</code> 回车符</li>
<li><code>\t</code> 制表符(Tab键)</li>
<li><code>\f</code> 换页符</li>
<li><code>\v</code> 垂直制表符</li>
<li><code>[\b]</code> 回退(并删除)一个字符(Backspace键)</li>
</ul>
<p>\r\n匹配一个“回车+换行”组合,有许多操作系统(比如Windows) 都把这个组合用作文本行的结束标签。</p>
<p>\r\n是Windows所使用的文本行结束标签。Unix和Linux 系统只使用一个换行符来结束一个文本行;换句话说,在 Unix/Linux系统上匹配空白行只使用\n\n即可,不需要加上\r。 同时适用于Windows和Unix/Linux系统的正则表达式应该包含 一个可选的\r和一个必须被匹配的\n。</p>
<p>字符集合(匹配多个字符中的某一个)是最常见的匹配形式, 而一些常用的字符集合可以用特殊元字符来代替:</p>
<ul>
<li><code>\d</code> 任何一个数字字符 (等价于 <code>[0-9]</code>)</li>
<li><code>\D</code> 任何一个非数字字符 (等价于 <code>[^0-9]</code>)</li>
<li><code>\w</code> 任何一个字母数字字符(大小写均可)或下划线字符 (等价于 <code>[a-zA-Z0-9_]</code>)</li>
<li><code>\W</code> 任何一个非字母数字或非下划线字符 (等价于 <code>[^a-zA-Z0-9_]</code>)</li>
<li><code>\s</code> 任何一个空白字符 (等价于 <code>[\f\n\r\t\v]</code>)</li>
<li><code>\S</code> 任何一个非空白字符(等价于 <code>[^\f\n\r\t\v]</code>)</li>
</ul>
<p>注意 用来匹配退格字符的 <code>[\b]</code> 元字符是一个特例: 它不在类元字符 <code>\s</code> 的覆盖范围内。</p>
<p>关于<code>-w</code>, 是一种比较常用的字符集合, 这些字符常见于各种名字里,如文件名、子目录名、变量名、数据库对象名等。</p>
<p>进制匹配:</p>
<ul>
<li><code>\x</code> 匹配十六进制。如 <code>\x0A</code> 等价于 <code>\n</code></li>
<li><code>\0</code> 匹配八进制。如 <code>\011</code> 等价于 <code>\t</code></li>
</ul>
<p>POSIX字符类是许多正则表达式实现都支持的一种简写形式:</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任何一个字母或数字 (等价于[a-zA-Z0-9])</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任何一个字母 (等价于[a-zA-Z])</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格或制表符 (等价于[\t])</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符 (ASCII 0到31，再加上ASCII 127)</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任何一个数字 (等价于[0-9])</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>和[:print:]一样，但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任何一个小写字母 (等价于[a-z])</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任何一个可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>任何一个空白字符，包括空格 (等价于[^\f\n\r\t\v])</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任何一个大写字母 (等价于[A-Z])</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任何一个十六进制数字 (等价于[a-fA-F0-9])</td>
</tr>
</tbody>
</table>
<p>例如下面匹配html中的rgb color:</p>
<div class="hlcode"><pre><span class="c">#[[:xdigit:]]{6}</span>
</pre></div>


<p>注意 这里使用的模式以 <code>[[</code> 开头、以 <code>]]</code> 结束 (两对方括号)。 这是使用POSIX字符类所必须的。POSIX字符类必须括在 <code>[:</code> 和 <code>:]</code> 之间,我们使用的POSIX字符类是 <code>[:xdigit:]</code>(不是<code>:xdigit:</code>)。外层的 <code>[</code> 和 <code>]</code> 字符用来定义一个字符集合, 内层的 <code>[</code> 和 <code>]</code> 字符是POSIX字符类本身的组成部分。</p>
<h2 id="5">第5章 重复匹配</h2>
<ul>
<li><code>+</code> 匹配一个或多个</li>
<li><code>*</code> 匹配零个或多个</li>
<li><code>?</code> 匹配零个或一个</li>
<li><code>{N}</code> 指定具体的重复匹配次数, 如 {3} 表示匹配3次</li>
<li><code>{M, N}</code> 指定重复匹配次数的区间, 如 {3, 5} 表示最少重复3次, 最多重复5次</li>
<li><code>{M, }</code> 指定最少重复多少次, 如 {3, } 表示重复3次或更多</li>
</ul>
<p>如:</p>
<div class="hlcode"><pre><span class="n">a</span><span class="o">+</span>  <span class="err">#</span> <span class="err">匹配一个或多个连续的</span><span class="n">a</span>
<span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>  <span class="err">#</span> <span class="err">匹配一个或多个连续的数字</span>
</pre></div>


<p>注意 <code>+</code>等元字, 如果在集合中, 则表示普通字符。</p>
<p>另外，<code>?</code>, <code>+</code>, <code>*</code>, <code>{m, n}</code> 都是「贪婪匹配 (greedy match)」的元字符，也就是他们会尽可能多的去匹配。如:</p>
<div class="hlcode"><pre><span class="err">$</span> <span class="n">cat</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">text</span> <span class="n">block</span> <span class="mi">1</span><span class="o">---</span><span class="n">text</span> <span class="n">block</span> <span class="mi">2</span><span class="o">---</span><span class="n">end</span>

<span class="err">$</span> <span class="n">grep</span> <span class="o">-</span><span class="n">P</span> <span class="o">-</span><span class="n">o</span> <span class="o">--</span> <span class="err">&#39;</span><span class="o">---</span><span class="p">.</span><span class="o">*---</span><span class="err">&#39;</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">text</span> <span class="n">block</span> <span class="mi">1</span><span class="o">---</span><span class="n">text</span> <span class="n">block</span> <span class="mi">2</span><span class="o">---</span>
</pre></div>


<p>某些情况需要尽可能的少的匹配, 即匹配第一次符合的就停止继续匹配, 也就是「懒惰匹配 (non-greedy match 或 lazy match)」, 只需要在贪婪的元字符后面加上 <code>?</code> 后缀:</p>
<div class="hlcode"><pre><span class="err">$</span> <span class="n">grep</span> <span class="o">-</span><span class="n">P</span> <span class="o">-</span><span class="n">o</span> <span class="o">--</span> <span class="err">&#39;</span><span class="o">---</span><span class="p">.</span><span class="o">*?---</span><span class="err">&#39;</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">text</span> <span class="n">block</span> <span class="mi">1</span><span class="o">---</span>
</pre></div>


<p>注解:</p>
<p>这里匹配三个减号符之间的内容, 因为 <code>-</code> 在命令行中有特殊含义, 表示命令行参数, 所以这里在所有参数选项后加上 <code>--</code> (bare double dash), <a href="http://stackoverflow.com/questions/2427913/how-can-i-grep-for-a-string-that-begins-with-a-dash-hyphen">参考</a>; 之前报错还没想到是这里的问题。</p>
<p>另外, <code>grep -G</code>, <code>grep -E</code> 都不支持懒惰匹配, 所以使用了Perl型的解析: <code>grep -P</code>。</p>
<p>最后, <code>grep -o</code> 只打印出匹配的内容, 这么看就比较直观了。</p>
<p>再比如:</p>
<div class="hlcode"><pre><span class="err">$</span> <span class="n">cat</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">abcdefg</span><span class="o">---</span><span class="mi">1234567</span><span class="o">---</span><span class="n">xxxxxxx</span>

<span class="err">$</span> <span class="n">grep</span> <span class="o">-</span><span class="n">P</span> <span class="o">-</span><span class="n">o</span> <span class="o">--</span> <span class="err">&#39;</span><span class="o">---</span><span class="p">.{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span><span class="err">&#39;</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">abcde</span>
<span class="o">---</span><span class="mi">12345</span>
<span class="o">---</span><span class="n">xxxxx</span>

<span class="err">$</span> <span class="n">grep</span> <span class="o">-</span><span class="n">P</span> <span class="o">-</span><span class="n">o</span> <span class="o">--</span> <span class="err">&#39;</span><span class="o">---</span><span class="p">.{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span><span class="o">?</span><span class="err">&#39;</span> <span class="n">txt</span>
<span class="o">---</span><span class="n">abc</span>
<span class="o">---</span><span class="mi">123</span>
<span class="o">---</span><span class="n">xxx</span>
</pre></div>


<p>在 <a href="http://code.tankywoo.com/UVMgMQ77/">正则匹配YAML Front Matter</a> 里也提到了懒惰匹配。</p>
    </div>

        </div>
        <div id="footer">
              <p>
                Copyright © 2012-2016 Tanky Woo.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
                Theme by <a href="https://github.com/tankywoo/yasimple" target="_blank">YASimple</a>.
              </p>
              <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
              <p>Last Update 2016-02-23 22:22:29</p>
              <p><a href="https://github.com/tankywoo/wiki.tankywoo.com">Fork me on Github</a></p>
        </div>
<script type="text/javascript">
	var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
	document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F754de327571c0ba7ff50a61fc964e196' type='text/javascript'%3E%3C/script%3E"));
</script>
    </body>
</html>