<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>TICK技术栈 - Wiki · Tanky Woo</title>
    <meta name="keywords" content="wiki, makrdown, linux, python, cpp, ops, simiki"/>
    <meta name="description" content="Tanky Woo's personal wiki, powered by vim and markdown. Focus on Python, C/C++, Linux, Ops-Dev, Gentoo, and so on."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/">Wiki · Tanky Woo</a>
    &nbsp;&#187;&nbsp;
    <a href="/#linux">linux</a>
    &nbsp;&#187;&nbsp;TICK技术栈
    <span class="updated">当前页面最后更新&nbsp;
    2017-08-24 10:28
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <p>TICK 是由 InfluxData 开发的一套运维工具栈，由 Telegraf, InfluxDB, Chronograf, Kapacitor 四个工具的首字母组成。</p>
<p>这一套组件将 收集数据和入库、数据库、绘图、告警四者囊括了。</p>
<p>结构如下（<a href="https://www.influxdata.com/time-series-platform/">图片来源</a>）：</p>
<p><img alt="TICK Stack" src="https://www.influxdata.com/wp-content/uploads/InfluxData_TICK.png" /></p>
<h2 id="influxdb">InfluxDB</h2>
<p>时序数据库工具。</p>
<p>详见另外一篇wiki：<a href="/database/influxdb.html">InfluxDB</a></p>
<h2 id="telegraf">Telegraf</h2>
<p>是一个数据收集和入库的工具。提供了很多 input 和 output 插件，比如收集本地的 cpu、load、网络流量等数据，然后写入 InfluxDB 或者 Kafka 等。</p>
<p>我们已经在几年前开发了一个性能数据收集工具，不过这个也简单了解过，感觉是目前 TICK 四大组件中也就这个和 InfluxDB 两者比较成熟了，使用用户也多一些。</p>
<h2 id="chronograf">Chronograf</h2>
<p>绘图工具，有点是绑定了 Kapacitor，缺点是难用。</p>
<p>所以我选择了成熟很多的 <a href="https://grafana.com/">Grafana</a>。</p>
<h2 id="kapacitor">Kapacitor</h2>
<p><a href="https://docs.influxdata.com/kapacitor/">Kapacitor</a> 是 InfluxData 家的告警工具，通过读取 InfluxDB 中的数据，根据 DLS 类型配置 TickScript 来进行告警。</p>
<p>说实话，Kapacitor 并没有给我什么感觉，应该目前依靠 Nagios 被动告警已经可以做到很好，而 Kapacitor 的 KickScript 则相对比较复杂，且目前这个工具还是不够成熟。</p>
<p>但是不妨碍我花点时间简单研究了解下，以作为以后告警的一个备选。</p>
<p>目前市面上没有看到有价值的文档，要么都是简介，实际例子没有，所以只看官方文档和它自带的例子吧，虽然我感觉写的比较简陋。</p>
<p>下面是 <a href="https://docs.influxdata.com/kapacitor/v1.3/introduction/getting_started/">Getting Started</a> 的一个简单小结（目前的研究版本是 v1.3）：</p>
<p>总得来说，Kapacitor 的依赖就 InfluxDB，文档说也可以不用 InfluxDB，不过没看出还支持哪些。</p>
<p><code>kapacitord</code> 生成配置并适当修改，启动，监听 http://0.0.0.0:9092，并主动向配置的 InfluxDB 配置订阅，通过 <code>SHOW SUBSCRIPTIONS</code> 可以看到增加的订阅信息，这样 InfluxDB 新接收的数据就会发送到 Kapacitor 上。</p>
<p><code>kapacitor</code> 是 Kapacitor 提供的管理工具，根据 http api 操作 Kapacitor，比如新增任务等。</p>
<p>Kapacitor 的认为分两种，一种是 <code>stream</code>，一种是 <code>batch</code>。<code>stream</code> 方式相当于 Kapacitor 一直接收 InfluxDB 传递过来的数据并做相应分析和告警；而 <code>batch</code> 则是自动定义查询间隔和周期，对数据做一些聚合计算后再告警。</p>
<p>简单的例子如：</p>
<div class="hlcode"><pre><span class="err">#</span> <span class="nx">InfluxDB</span> <span class="err">创建数据库</span>
<span class="nb">CREATE</span> <span class="nx">DATABASE</span> <span class="nx">mydb</span>

<span class="err">#</span> <span class="err">编写</span> <span class="nx">tick</span> <span class="err">脚本</span>
<span class="err">$</span> <span class="nx">cat</span> <span class="nx">tick</span><span class="p">/</span><span class="nx">load_alert.tick</span>
<span class="nx">stream</span>
    <span class="o">|</span><span class="nb">from</span><span class="p">()</span>
        <span class="bp">.</span><span class="nx">measurement</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">)</span>
    <span class="o">|</span><span class="nx">alert</span><span class="p">()</span>
        <span class="bp">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">lambda</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span> <span class="o">&gt;</span> <span class="mf">3.2</span><span class="p">)</span>
        <span class="bp">.</span><span class="nx">crit</span><span class="p">(</span><span class="nx">lambda</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span> <span class="o">&gt;</span> <span class="mf">3.5</span><span class="p">)</span>
        <span class="bp">.</span><span class="nb">log</span><span class="p">(</span><span class="s1">&#39;/tmp/alerts.log&#39;</span><span class="p">)</span>

<span class="err">#</span> <span class="err">定义这个任务，指定名称，</span><span class="nx">tick</span><span class="err">脚本，</span><span class="nb">db</span><span class="err">和</span><span class="nx">rp</span>
<span class="nx">kapacitor</span> <span class="kd">define</span> <span class="nf">load_alert</span> <span class="na">-type</span> <span class="nx">stream</span> <span class="na">-tick</span> <span class="nx">tick</span><span class="p">/</span><span class="nx">load_alert.tick</span> <span class="na">-dbrp</span> <span class="nx">mydb.autogen</span>

<span class="err">#</span> <span class="err">在启用这个任务前，先截取当前的数据测试下，发现告警泛滥</span>
<span class="err">#</span> <span class="nx">record</span> <span class="err">会生成一个</span> <span class="nx">recording</span> <span class="nb">id</span>
<span class="nx">kapacitor</span> <span class="nx">record</span> <span class="nx">stream</span> <span class="na">-task</span> <span class="nx">load_alert</span> <span class="na">-duration</span> <span class="mi">20</span><span class="nb">s</span>
<span class="err">#</span> <span class="nx">replay</span> <span class="err">回放时根据这个</span> <span class="nb">id</span> <span class="err">来回放</span>
<span class="nx">kapacitor</span> <span class="nx">replay</span> <span class="na">-recording</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span> <span class="na">-task</span> <span class="nx">load_alert</span>

<span class="err">#</span> <span class="err">确认</span> <span class="p">/</span><span class="nx">tmp</span><span class="p">/</span><span class="nx">alert.log</span><span class="err">，如果告警预期，则可以考虑开启任务</span>
<span class="nx">kapacitor</span> <span class="nx">enable</span> <span class="nx">load_alert</span>

<span class="err">#</span> <span class="err">任何时候如果更新了</span> <span class="nx">tick</span> <span class="err">脚本，只需要再次执行</span> <span class="k">define</span> <span class="err">语句即可</span>
<span class="err">#</span> <span class="err">可以在修改并</span><span class="k">define</span><span class="err">后，执行</span> <span class="nx">replay</span> <span class="err">看看此时告警情况</span>
</pre></div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2012-2017 Tanky Woo.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://git.coding.net/tankywoo/yasimple_x2.git" target="_blank">YASimple_X2</a>.
        </p>
        <p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>站点最后生成 2017-08-25 16:16:57</p>
        <p><a href="https://github.com/tankywoo/wiki.tankywoo.com">Fork me on Github</a></p>
        <p><a href="http://www.miitbeian.gov.cn/">京ICP备16016622号</a></p>
      </div> <!-- end footer-right -->
    </div>

    
    

    <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F754de327571c0ba7ff50a61fc964e196' type='text/javascript'%3E%3C/script%3E"));
    </script>
  </body>
</html>