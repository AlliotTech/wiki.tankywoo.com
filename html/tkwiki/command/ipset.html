<!DOCTYPE HTML>
<html>
	<head>
		<link rel="Stylesheet" type="text/css" href="/css/style.css">
		<title>IPSET @ TankyWoo's Wiki</title>
		<meta name="keywords" content="TankyWoo, Wiki, vimwiki, linux, python, cpp"/>
		<meta name="description" content="A wiki about Linux, Python, and so on"/>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>

        <a href="https://github.com/tankywoo/wiki"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>

	</head>
	<body>
		<div id="header">
			<ul>
				<li><a href='/'>Home</a></li>
				<li><a href='http://www.wutianqi.com'>Blog</a></li>
				<li><a href='https://github.com/tankywoo/wiki'>Github</a></li>
			</ul>
		</div>
		<div class="clearfix">
		</div>
		<div id="title">IPSET</div>
		<div id="content">
			

<p>
[ Ref: <a href="http://www.linuxjournal.com/content/advanced-firewall-configurations-ipset ">Advanced Firewall Configurations with ipset</a> ]
</p>

<hr />

<p>
iptables has been the Linux firewall solution since the 2.4 kernel.<br />
iptables在kernel2.4后已经是Linux防火墙的解决方案
</p>

<p>
ipset is an extension to iptables that allows you to create firewall rules that match entire "sets" of addresses at once. Unlike normal iptables chains, which are stored and traversed linearly, IP sets are stored in indexed data structures, making lookups very efficient, even when dealing with large sets.<br />
ipset是iptables的扩展，可以让你添加规则来匹配地址集合。不同于常规的iptables链是线性的存储和遍历，ipset是用索引数据结构存储，甚至对于大型集合，查询效率非常都优秀。
</p>

<p>
Besides the obvious situations where you might imagine this would be useful, such as blocking long lists of "bad" hosts without worry of killing system resources or causing network congestion, IP sets also open up new ways of approaching certain aspects of firewall design and simplify many configuration scenarios.<br />
除了可以看见的解决方案，例如防止长主机列表造成的系统资源耗尽，ipset还开创了新方式来设计防火墙和简化许多规则。
</p>

<h2 id="toc_0.1">Getting ipset</h2>
<p>
TODO
</p>

<h2 id="toc_0.2">iptables Overview</h2>
<p>
TODO
</p>

<h2 id="toc_0.3">Enter ipset</h2>
<p>
ipset is a "match extension" for iptables. To use it, you create and populate uniquely named "sets" using the ipset command-line tool, and then separately reference those sets in the match specification of one or more iptables rules.<br />
ipset用于iptables的"匹配扩展"。要使用它，需要通过ipset的命令行工具创建一个集合，然后分别在一个或多格iptables规则中引用这个set
</p>

<p>
A set is simply a list of addresses stored efficiently for fast lookup.<br />
</p>

<p>
Take the following normal iptables commands that would block inbound traffic from 1.1.1.1 and 2.2.2.2:
</p>
<pre>
iptables -A INPUT -s 1.1.1.1 -j DROP
iptables -A INPUT -s 2.2.2.2 -j DROP
</pre>
<p>
The match specification syntax -s 1.1.1.1 above means "match packets whose source address is 1.1.1.1". To block both 1.1.1.1 and 2.2.2.2, two separate iptables rules with two separate match specifications (one for 1.1.1.1 and one for 2.2.2.2) are defined above.
</p>

<p>
Alternatively, the following ipset/iptables commands achieve the same result:
</p>
<pre>
ipset -N myset iphash
ipset -A myset 1.1.1.1
ipset -A myset 2.2.2.2
iptables -A INPUT -m set --set myset src -j DROP
</pre>
<p>
The ipset commands above create a new set (myset of type iphash) with two addresses (1.1.1.1 and 2.2.2.2).
</p>

<p>
The iptables command then references the set with the match specification -m set --set myset src, which means "match packets whose source header matches (that is, is contained within) the set named myset".
</p>

<p>
The flag src means match on "source". The flag dst would match on "destination", and the flag src,dst would match on both source and destination.
</p>

<p>
In the second version above, only one iptables command is required, regardless of how many additional IP addresses are contained within the set. Although this example uses only two addresses, you could just as easily define 1,000 addresses, and the ipset-based config still would require only a single iptables rule, while the previous approach, without the benefit of ipset, would require 1,000 iptables rules.<br />
在上面的第二个版本，尽管这个例子只写了两个地址。但是不管ipset包含多少个ip地址，都只需要一条iptables命令。你可以定义1000个地址，iptables依然只需要一条规则。在第一个版本中，没有ipset，所以需要1000个iptables规则。
</p>


<h2 id="toc_0.4">Set Types</h2>

<p>
Each set is of a specific type, which defines what kind of values can be stored in it (IP addresses, networks, ports and so on) as well as how packets are matched (that is, what part of the packet should be checked and how it's compared to the set). Besides the most common set types, which check the IP address, additional set types are available that check the port, the IP address and port together, MAC address and IP address together and so on.<br />
每一个set都需要一个特定的类型，用于定义它可以存储什么样的类型(IP地址、网络、端口等等)以及包如何匹配(即，包的什么部分应该被检查以及它是如何和set做匹配)。除了检查IP地址这个最常用的set类型，还有端口、IP地址和端口一起、MAC地址和IP地址一起，等等。
</p>


<p>
Each set type has its own rules for the type, range and distribution of values it can contain. Different set types also use different types of indexes and are optimized for different scenarios. The best/most efficient set type depends on the situation.
</p>

<p>
The most flexible set types are iphash, which stores lists of arbitrary IP addresses, and nethash, which stores lists of arbitrary networks (IP/mask) of varied sizes. Refer to the ipset man page for a listing and description of all the set types (there are 11 in total at the time of this writing).<br />
最灵活的set类型是<code>iphash</code>，可以存储任意的IP地址列表和任意的网络(IP/MASK)列表。ipset的man page列出和描述了所有的set类型(在写这篇文章时总共有11种类型)
</p>


<p>
The special set type setlist also is available, which allows grouping several sets together into one. This is required if you want to have a single set that contains both single IP addresses and networks, for example.
</p>

<h2 id="toc_0.5">Advantages of ipset</h2>

<p>
Besides the performance gains, ipset also allows for more straightforward configurations in many scenarios.
除开性能上的获取，ipset还允许在许多场景下做更多简洁的配置。
</p>

<p>
If you want to define a firewall condition that would match everything but packets from 1.1.1.1 or 2.2.2.2 and continue processing in mychain, notice that the following does not work:
</p>
<pre>
iptables -A INPUT -s ! 1.1.1.1 -g mychain
iptables -A INPUT -s ! 2.2.2.2 -g mychain
</pre>
<p>
If a packet came in from 1.1.1.1, it would not match the first rule (because the source address is 1.1.1.1), but it would match the second rule (because the source address is not 2.2.2.2). If a packet came in from 2.2.2.2, it would match the first rule (because the source address is not 1.1.1.1). The rules cancel each other out—all packets will match, including 1.1.1.1 and 2.2.2.2.
</p>

<p>
Although there are other ways to construct the rules properly and achieve the desired result without ipset, none are as intuitive or straightforward:
</p>
<pre>
ipset -N myset iphash
ipset -A myset 1.1.1.1
ipset -A myset 2.2.2.2
iptables -A INPUT -m set ! --set myset src -g mychain
</pre>
<p>
In the above, if a packet came in from 1.1.1.1, it would not match the rule (because the source address 1.1.1.1 does match the set myset). If a packet came in from 2.2.2.2, it would not match the rule (because the source address 2.2.2.2 does match the set myset).
</p>

<p>
Although this is a simplistic example, it illustrates the fundamental benefit associated with fitting a complete condition in a single rule. In many ways, separate iptables rules are autonomous from each other, and it's not always straightforward, intuitive or optimal to get separate rules to coalesce into a single logical condition, especially when it involves mixing normal and inverted tests. ipset just makes life easier in these situations.<br />// TODO
</p>

<p>
Another benefit of ipset is that sets can be manipulated independently of active iptables rules. Adding/changing/removing entries is a trivial matter because the information is simple and order is irrelevant. Editing a flat list doesn't require a whole lot of thought. In iptables, on the other hand, besides the fact that each rule is a significantly more complex object, the order of rules is of fundamental importance, so in-place rule modifications are much heavier and potentially error-prone operations.
</p>

<h2 id="toc_0.6">Excluding WAN, VPN and Other Routed Networks from the NAT—the Right Way</h2>

<p>
Outbound NAT (SNAT or IP masquerade) allows hosts within a private LAN to access the Internet. An appropriate iptables NAT rule matches Internet-bound packets originating from the private LAN and replaces the source address with the address of the gateway itself (making the gateway appear to be the source host and hiding the private "real" hosts behind it).
// TODO	Outbound NAT?
</p>

<p>
NAT automatically tracks the active connections so it can forward return packets back to the correct internal host (by changing the destination from the address of the gateway back to the address of the original internal host).
NAT自动跟踪活动的链接，所以它可以返回包到正确的内部主机(通过网络地址改回目的地址到原来的内部主机地址)
</p>

<p>
Here is an example of a simple outbound NAT rule that does this, where 10.0.0.0/24 is the internal LAN:
</p>
<pre>
iptables -t nat -A POSTROUTING \
         -s 10.0.0.0/24 -j MASQUERADE
</pre>
<p>
This rule matches all packets coming from the internal LAN and masquerades them (that is, it applies "NAT" processing). This might be sufficient if the only route is to the Internet, where all through traffic is Internet traffic. If, however, there are routes to other private networks, such as with VPN or physical WAN links, you probably don't want that traffic masqueraded.<br />
这个规则匹配所有来至局域网内部的数据包，并且伪装他们(即，它适用NAT处理#TODO?)。如果唯一的路由是通向Internet，所有通过的流量都是Internet流量，也许会比较足够。但是，会有一些到私有网络的路由，比如VPN或屋里WAN链路，你应该不希望流量伪装。 #TODO 这一段翻译的好蛋疼
</p>

<p>
One simple way (partially) to overcome this limitation is to base the NAT rule on physical interfaces instead of network numbers (this is one of the most popular NAT rules given in on-line examples and tutorials):
</p>
<pre>
iptables -t nat -A POSTROUTING \
         -o eth0 -j MASQUERADE
</pre>
<p>
This rule assumes that eth0 is the external interface and matches all packets that leave on it. Unlike the previous rule, packets bound for other networks that route out through different interfaces won't match this rule (like with OpenVPN links).<br />
这条规则假设eth0是外网口并且匹配所有通过它出去的数据包。不同于前一条规则，绑定其他网络通过不同的网卡出去的数据包不会匹配这条规则(例如OpenVPN链路)
</p>

<p>
Although many network connections may route through separate interfaces, it is not safe to assume that all will. A good example is KAME-based IPsec VPN connections (such as Openswan) that don't use virtual interfaces like other user-space VPNs (such as OpenVPN).<br />
尽管许多网络连接可能会通过不同的网卡出去，但假设所有都会并不安全。一个很好的例子就是KAME-based IPsec VPN连接(例如Openswan)不会像其他user-space VPNs(例如OpenVPN)一样使用虚拟网卡。
</p>

<p>
Another situation where the above interface match technique wouldn't work is if the outward facing ("external") interface is connected to an intermediate network with routes to other private networks in addition to a route to the Internet. It is entirely plausible for there to be routes to private networks that are several hops away and on the same path as the route to the Internet.<br />// TODO
</p>

<p>
Designing firewall rules that rely on matching of physical interfaces can place artificial limits and dependencies on network topology, which makes a strong case for it to be avoided if it's not actually necessary.
</p>

<p>
As it turns out, this is another great application for ipset. Let's say that besides acting as the Internet gateway for the local private LAN (10.0.0.0/24), your box routes directly to four other private networks (10.30.30.0/24, 10.40.40.0/24, 192.168.4.0/23 and 172.22.0.0/22). Run the following commands:
</p>
<pre>
ipset -N routed_nets nethash
ipset -A routed_nets 10.30.30.0/24
ipset -A routed_nets 10.40.40.0/24
ipset -A routed_nets 192.168.4.0/23
ipset -A routed_nets 172.22.0.0/22
iptables -t nat -A POSTROUTING \
         -s 10.0.0.0/24 \
         -m set ! --set routed_nets dst \
         -j MASQUERADE
</pre>
<p>
As you can see, ipset makes it easy to zero in on exactly what you want matched and what you don't. This rule would masquerade all traffic passing through the box from your internal LAN (10.0.0.0/24) except those packets bound for any of the networks in your routed_nets set, preserving normal direct IP routing to those networks. Because this configuration is based purely on network addresses, you don't have to worry about the types of connections in place (type of VPNs, number of hops and so on), nor do you have to worry about physical interfaces and topologies.
</p>

<p>
This is how it should be. Because this is a pure layer-3 (network layer) implementation, the underlying classifications required to achieve it should be pure layer-3 as well.
</p>


<h2 id="toc_0.7">Limiting Certain PCs to Have Access Only to Certain Public Hosts</h2>

<p>
Let's say the boss is concerned about certain employees playing on the Internet instead of working and asks you to limit their PCs' access to a specific set of sites they need to be able to get to for their work, but he doesn't want this to affect all PCs (such as his).
</p>

<p>
To limit three PCs (10.0.0.5, 10.0.0.6 and 10.0.0.7) to have outside access only to worksite1.com, worksite2.com and worksite3.com, run the following commands:
</p>
<pre>
ipset -N limited_hosts iphash
ipset -A limited_hosts 10.0.0.5
ipset -A limited_hosts 10.0.0.6
ipset -A limited_hosts 10.0.0.7
ipset -N allowed_sites iphash
ipset -A allowed_sites worksite1.com
ipset -A allowed_sites worksite2.com
ipset -A allowed_sites worksite3.com
iptables -I FORWARD \
         -m set --set limited_hosts src \
         -m set ! --set allowed_sites dst \
         -j DROP
</pre>
<p>
This example matches against two sets in a single rule. If the source matches limited_hosts and the destination does not match allowed_sites, the packet is dropped (because limited_hosts are allowed to communicate only with allowed_sites).
</p>

<p>
Note that because this rule is in the FORWARD chain, it won't affect communication to and from the firewall itself, nor will it affect internal traffic (because that traffic wouldn't even involve the firewall).
</p>


<h2 id="toc_0.8">Blocking Access to Hosts for All but Certain PCs (Inverse Scenario)</h2>

<p>
Let's say the boss wants to block access to a set of sites across all hosts on the LAN except his PC and his assistant's PC. For variety, in this example, let's match the boss and assistant PCs by MAC address instead of IP. Let's say the MACs are 11:11:11:11:11:11 and 22:22:22:22:22:22, and the sites to be blocked for everyone else are badsite1.com, badsite2.com and badsite3.com.
</p>

<p>
In lieu of using a second ipset to match the MACs, let's utilize multiple iptables commands with the MARK target to mark packets for processing in subsequent rules in the same chain:
</p>
<pre>
ipset -N blocked_sites iphash
ipset -A blocked_sites badsite1.com
ipset -A blocked_sites badsite2.com
ipset -A blocked_sites badsite3.com
iptables -I FORWARD -m mark --mark 0x187 -j DROP
iptables -I FORWARD \
         -m mark --mark 0x187 \
         -m mac --mac-source 11:11:11:11:11:11 \
         -j MARK --set-mark 0x0
iptables -I FORWARD \
         -m mark --mark 0x187 \
         -m mac --mac-source 22:22:22:22:22:22 \
         -j MARK --set-mark 0x0
iptables -I FORWARD \
         -m set --set blocked_sites dst \
         -j MARK --set-mark 0x187
</pre>
<p>
As you can see, because you're not using ipset to do all the matching work as in the previous example, the commands are quite a bit more involved and complex. Because there are multiple iptables commands, it's necessary to recognize that their order is vitally important.
</p>

<p>
Notice that these rules are being added with the -I option (insert) instead of -A (append). When a rule is inserted, it is added to the top of the chain, pushing all the existing rules down. Because each of these rules is being inserted, the effective order is reversed, because as each rule is added, it is inserted above the previous one.
</p>

<p>
The last iptables command above actually becomes the first rule in the FORWARD chain. This rule matches all packets with a destination matching the blocked_sites ipset, and then marks those packets with 0x187 (an arbitrarily chosen hex number). The next two rules match only packets from the hosts to be excluded and that are already marked with 0x187. These two rules then set the marks on those packets to 0x0, which "clears" the 0x187 mark.
</p>

<p>
Finally, the last iptables rule (which is represented by the first iptables command above) drops all packets with the 0x187 mark. This should match all packets with destinations in the blocked_sites set except those packets coming from either of the excluded MACs, because the mark on those packets is cleared before the DROP rule is reached.
</p>

<p>
This is just one way to approach the problem. Other than using a second ipset, another way would be to utilize user-defined chains.
</p>

<p>
If you wanted to use a second ipset instead of the mark technique, you wouldn't be able to achieve the exact outcome as above, because ipset does not have a machash set type. There is a macipmap set type, however, but this requires matching on IP and MACs together, not on MAC alone as above.
</p>

<p>
Cautionary note: in most practical cases, this solution would not actually work for Web sites, because many of the hosts that might be candidates for the blocked_sites set (like Facebook, MySpace and so on) may have multiple IP addresses, and those IPs may change frequently. A general limitation of iptables/ipset is that hostnames should be specified only if they resolve to a single IP.
</p>

<p>
Also, hostname lookups happen only at the time the command is run, so if the IP address changes, the firewall rule will not be aware of the change and still will reference the old IP. For this reason, a better way to accomplish these types of Web access policies is with an HTTP proxy solution, such as Squid. That topic is obviously beyond the scope of this article.
</p>


<h2 id="toc_0.9">Automatically Ban Hosts That Attempt to Access Invalid Services</h2>

<p>
ipset also provides a "target extension" to iptables that provides a mechanism for dynamically adding and removing set entries based on any iptables rule. Instead of having to add entries manually with the ipset command, you can have iptables add them for you on the fly.
</p>

<p>
For example, if a remote host tries to connect to port 25, but you aren't running an SMTP server, it probably is up to no good. To deny that host the opportunity to try anything else proactively, use the following rules:
</p>
<pre>
ipset -N banned_hosts iphash
iptables -A INPUT \
         -p tcp --dport 25 \
         -j SET --add-set banned_hosts src
iptables -A INPUT \
         -m set --set banned_hosts src \
         -j DROP
</pre>
<p>
If a packet arrives on port 25, say with source address 1.1.1.1, it instantly is added to banned_hosts, just as if this command were run:
</p>
<pre>
ipset -A banned_hosts 1.1.1.1
</pre>
<p>
All traffic from 1.1.1.1 is blocked from that moment forward because of the DROP rule.
</p>

<p>
Note that this also will ban hosts that try to run a port scan unless they somehow know to avoid port 25.
</p>


<h2 id="toc_0.10">Clearing the Running Config</h2>

<p>
If you want to clear the ipset and iptables config (sets, rules, entries) and reset to a fresh open firewall state (useful at the top of a firewall script), run the following commands:
</p>
<pre>
iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -t filter -F
iptables -t raw -F
iptables -t nat -F
iptables -t mangle -F
ipset -F
ipset -X
</pre>
<p>
Sets that are "in use", which means referenced by one or more iptables rules, cannot be destroyed (with ipset -X). So, in order to ensure a complete "reset" from any state, the iptables chains have to be flushed first (as illustrated above).
</p>

<h2 id="toc_0.11">Conclusion</h2>

<p>
ipset adds many useful features and capabilities to the already very powerful netfilter/iptables suite. As described in this article, ipset not only provides new firewall configuration possibilities, but it also simplifies many setups that are difficult, awkward or less efficient to construct with iptables alone.
</p>

<p>
Any time you want to apply firewall rules to groups of hosts or addresses at once, you should be using ipset. As I showed in a few examples, you also can combine ipset with some of the more exotic iptables features, such as packet marking, to accomplish all sorts of designs and network policies.
</p>

<p>
The next time you're working on your firewall setup, consider adding ipset to the mix. I think you will be surprised at just how useful and flexible it can be.
</p>

<h2 id="toc_0.12">Resources</h2>

<p>
Netfilter/iptables Project Home Page: <a href="http://www.netfilter.org">http://www.netfilter.org</a>
</p>

<p>
ipset Home Page: <a href="http://ipset.netfilter.org">http://ipset.netfilter.org</a>
</p>

		</div>

		<div id="footer">
			<span class="">Copyright © 2012 <a href="http://www.wutianqi.com/" target="_blank">Tanky Woo</a> 
				Powered by <a href="http://www.vim.org/" target="_blank">Vim</a> and <a href="http://code.google.com/p/vimwiki/" target="_blank">Vimwiki</a>
			</span>
		</div>
	</body>
	
	<!-- add _blank to outer links -->
	<script type="text/javascript">
	$("a[href^='http://']").each(function(){
			this.target = "_blank";
	});

	$("a[href^='https://']").each(function(){
			this.target = "_blank";
	});

	$('h2').prepend('>> ')
	$('h3').prepend('>>> ')

	</script>
</html>
